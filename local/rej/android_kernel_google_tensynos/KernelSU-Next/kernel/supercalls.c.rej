--- kernel/supercalls.c
+++ kernel/supercalls.c
@@ -11,6 +11,10 @@
 #include <linux/task_work.h>
 #include <linux/uaccess.h>
 #include <linux/version.h>
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/namei.h>
+#include <linux/susfs.h>
+#endif // #ifdef CONFIG_KSU_SUSFS
 
 #include "supercalls.h"
 #include "arch.h"
@@ -110,6 +116,9 @@ static int do_report_event(void __user *arg)
             boot_complete_lock = true;
             pr_info("boot_complete triggered\n");
             on_boot_completed();
+#ifdef CONFIG_KSU_SUSFS
+            susfs_start_sdcard_monitor_fn();
+#endif // #ifdef CONFIG_KSU_SUSFS
         }
         break;
     }
@@ -359,6 +368,7 @@ static int do_manage_mark(void __user *arg)
 
     switch (cmd.operation) {
     case KSU_MARK_GET: {
+#ifndef CONFIG_KSU_SUSFS
         // Get task mark status
         ret = ksu_get_task_mark(cmd.pid);
         if (ret < 0) {
@@ -367,8 +377,19 @@ static int do_manage_mark(void __user *arg)
         }
         cmd.result = (u32)ret;
         break;
+#else
+        if (susfs_is_current_proc_umounted()) {
+            ret = 0; // SYSCALL_TRACEPOINT is NOT flagged
+        } else {
+            ret = 1; // SYSCALL_TRACEPOINT is flagged
+        }
+        pr_info("manage_mark: ret for pid %d: %d\n", cmd.pid, ret);
+        cmd.result = (u32)ret;
+        break;
+#endif // #ifndef CONFIG_KSU_SUSFS
     }
     case KSU_MARK_MARK: {
+#ifndef CONFIG_KSU_SUSFS
         if (cmd.pid == 0) {
             ksu_mark_all_process();
         } else {
@@ -379,9 +400,15 @@ static int do_manage_mark(void __user *arg)
                 return ret;
             }
         }
+#else
+        if (cmd.pid != 0) {
+            return ret;
+        }
+#endif // #ifndef CONFIG_KSU_SUSFS
         break;
     }
     case KSU_MARK_UNMARK: {
+#ifndef CONFIG_KSU_SUSFS
         if (cmd.pid == 0) {
             ksu_unmark_all_process();
         } else {
@@ -392,11 +419,20 @@ static int do_manage_mark(void __user *arg)
                 return ret;
             }
         }
+#else
+        if (cmd.pid != 0) {
+            return ret;
+        }
+#endif // #ifndef CONFIG_KSU_SUSFS
         break;
     }
     case KSU_MARK_REFRESH: {
+#ifndef CONFIG_KSU_SUSFS
         ksu_mark_running_process();
         pr_info("manage_mark: refreshed running processes\n");
+#else
+        pr_info("susfs: cmd: KSU_MARK_REFRESH: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
         break;
     }
     default: {
@@ -811,17 +963,23 @@ void ksu_supercalls_init(void)
                 ksu_ioctl_handlers[i].cmd);
     }
 
+#ifndef CONFIG_KSU_SUSFS
     int rc = register_kprobe(&reboot_kp);
     if (rc) {
         pr_err("reboot kprobe failed: %d\n", rc);
     } else {
         pr_info("reboot kprobe registered successfully\n");
     }
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 void ksu_supercalls_exit(void)
 {
+#ifndef CONFIG_KSU_SUSFS
     unregister_kprobe(&reboot_kp);
+#else
+    pr_info("susfs: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 // IOCTL dispatcher
